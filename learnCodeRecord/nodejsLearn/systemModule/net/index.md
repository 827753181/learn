# 什么是 TCP 协议？什么情况下又会选择 TCP 协议呢？

TCP 是传输控制协议，大多数情况下我们都会使用这个协议，因为它是一个更**可靠**的数据传输协议，具有如下三个特点：

- 面向链接：  
  需要对方主机在线，并建立链接
- 面向字节流:  
  你给我一堆字节流的数据，我给你发送出去，但是每次发送多少是我说了算，每次选出一段字节发送的时候，都会带上一个序号，这个序号就是发送的这段字节中编号最小的字节的编号。
- 可靠:  
  保证数据有序的到达对方主机，每发送一个数据就会期待收到对方的回复，如果在指定时间内收到了对方的回复，就确认为数据到达，如果超过一定时间没收到对方回复，就认为对方没收到，在重新发送一遍。

# TCP 粘包问题

## 本质

客户端在发送之前会将短时间多个发送的数据块缓存到一块，形成一个大数据块一起发送，接收端也一样有一个缓冲区，收到数据放到缓冲区，出现从这里读取部分数据消费。

## TCP 粘包解决方案?

- 方案一：延迟发送

  ```
    client.on('connect', () => {
        client.setNoDelay(true);
        // 向服务器发送数据
        client.write('Nodejs 技术栈');

        const arr = [
            'JavaScript ',
            'TypeScript ',
            'Python ',
            'Java ',
            'C ',
            'PHP ',
            'ASP.NET '
        ]

        for (let i=0; i<arr.length; i++) {
            (function(val, k){
                setTimeout(() => {
                    client.write(val);
                }, 1000 * (k+1))
            }(arr[i], i));
        }
    })
  ```

- 方案二：关闭 Nagle 算法

  > Nagle 算法是一种改善网络传输效率的算法，避免网络中充斥着大量小的数据块，它所期望的是尽可能发送大的数据块，因此在每次请求一个数据块给 TCP 发送时，TCP 并不会立即执行发送，而是等待一小段时间进行发送。

  > 当网络中充斥着大量小数据块时，Nagle 算法能将小的数据块集合起来一起发送减少了网络拥堵，这个还是很有帮助的，但也并不是所有场景都需要这样，例如，REPL 终端交互，当用户输入单个字符以获取响应，所以在 Node.js 中可以设置 socket.setNoDelay() 方法来关闭 Nagle 算法。

  > 但关闭 Nagle 算法并不总是有效的，因为其是在服务端完成合并，TCP 接收到数据会先存放于自己的缓冲区中，然后通知应用接收，应用层因为网络或其它的原因若不能及时从 TCP 缓冲区中取出数据，也会造成 TCP 缓冲区中存放多段数据块，就又会形成粘包。

  ```
      const server = net.createServer();

      server.on('connection', socket => {
          socket.setNoDelay(true);
      })
  ```

- **方案三：封包/拆包**(业内用的比较多的方案)

  > 前面两种方案都不是特别理想的，这里介绍第三种封包/拆包，也是目前业界用的比较多的，这里使用长度编码的方式，通信双方约定好格式，将消息分为定长的消息头（Header）和不定长的消息体（Body），在解析时读取消息头获取到内容占用的长度，之后读取到的消息体内容字节数等于字节头的字节数时，我们认为它是一个完整的包。

  | 消息头序号 (Header) | 消息体长度 (Header) | 消息体 (Body) |
  | ------------------- | ------------------- | ------------- |
  | SerialNumber        | bodyLength          | body          |
  | 2（字节）           | 2（字节）           | N(字节)       |

  TCP 底层传输是基于二进制数据，但是我们应用层通常是易于表达的字符串、数字等，这里第一步在编码的实现中，就需要先将我们的数据通过 Buffer 转为二进制数据，取出的时候同样也需要解码操作，一切尽在代码里，实现代码见 transcoder.ts
