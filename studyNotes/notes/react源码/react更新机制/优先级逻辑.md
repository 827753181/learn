# 如何保证最终状态正确

当某个Update由于优先级低被跳过是，存在BaseUpdate中的不仅是该Update，还有链表中该Update之后的所有Update

考虑如下例子：
```
baseState: ''
shared.pending: A1 --> B2 --> C1 --> D2
其中字母代表该Update要在页面插入的字母，数字代表优先级，值越低优先级越高。
```

第一次render，优先级为1。
```
baseState: ''
baseUpdate: null
render阶段使用的Update: [A1, C1]
memoizedState: 'AC'
```
其中B2由于优先级为2，低于当前优先级，所以他及其后面的所有Update会被保存在baseUpdate中作为下次更新的Update（即B2 C1 D2）。

这么做是为了保持状态的前后依赖顺序。

第二次render，优先级为2。
```
baseState: 'A'
baseUpdate: B2 --> C1 --> D2
render阶段使用的Update: [B2, C1, D2]
memoizedState: 'ABCD'
```
注意这里baseState并不是上一次更新的memoizedState。这是由于B2被跳过了。

***即当有Update被跳过时，下次更新的baseState !== 上次更新的memoizedState。(划重点)***

通过以上例子我们可以发现，React保证最终的状态一定和用户触发的交互一致，但是中间过程状态可能由于设备不同而不同。



# 如何保证Update不丢失
在render阶段，shared.pending被同时连接在workInProgress updateQueue.lastBaseUpdate与current updateQueue.lastBaseUpdate后面

当当前任务是高优先级任务，强形插入并在commit阶段完成渲染时：
  由于workInProgress updateQueue.lastBaseUpdate中保存了上一次的Update，所以 workInProgress Fiber树变成current Fiber树后也不会造成之前低优先级任务Update丢失。

当高优先级任务介入并完成render后，当前低优先级任务render阶段中断重新开始时：
  会基于current updateQueue克隆出workInProgress updateQueue。由于此时 current updateQueue.lastBaseUpdate已经保存了之前的Update，所以不会丢失。

