|        | Read uncommitted(读未提交) | READ COMMITTED (读提交)             | REPEATABLE READ（可重复读）       | Serializable(可序化)           |
| ------ | -------------------------- | ----------------------------------- | --------------------------------- | ------------------------------ |
| 写事务 | 允许其他事务 读            | 禁止其他事务访问（不允许读写）      | 禁止其他事务访问（不允许读写）    | 禁止其他事务访问（不允许读写） |
| 读事务 | 允许其他事务 读写          | 允许其他事务 读写 (读取使用快照读） | 允许其他事务 读 (读取使用快照读） | 禁止其他事务访问（不允许读写） |

| 事务隔离级别              | 描述                                           | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ------------------------- | ---------------------------------------------- | ---- | ---------- | ---- | ------ |
| 未提交读 read uncommitted | 一个事务可以读取到其他事务未提交的数据         | √    | √          | √    |        |
| 已提交读 read committed   | 一个事务只能读取到其他事务已提交的数据         |      | √          | √    |        |
| 可重复读 repeatable read  | 一个事务多次读取同样的数据结果是一样的         |      |            | √    |
| 可序列化 serializable     | 所有的事务都是串行执行的，不存在事务的并发操作 |      |            |      | √      |

原文链接：https://blog.csdn.net/weixin_43453386/article/details/125025277



# 脏读、不可重复读、幻读：
也许有很多读者会对上述隔离级别中提及到的 脏读、不可重复读、幻读 的理解有点吃力，我在这里尝试使用通俗的方式来解释这三种语义：

**脏读** ：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。

也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。

**不可重复读** ：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了。  
同样的条件, 你读取过的数据, 再次读取出来发现值不一样了，就是所谓的不可重复读了。

也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。

**幻读** ：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。（可通过排他锁和共享锁解决）

也就是说，同样的条件, 第1次和第2次读出来的记录数不一样。

**不可重复读和幻读比较**：
两者有些相似，但是前者针对的是update，后者针对的insert和delete。